/**
  * STM32 桌宠 - 最终融合版
  * 功能：
  * 1. 动态大眼睛 (眨眼 + 变表情)
  * 2. 距离闭环控制 (你进我退，你退我进)
  */
/* USER CODE END Header */

#include "main.h"
#include "oled.h"
#include <stdio.h>
#include <stdlib.h> // 为了使用 abs() 函数

/* --- 变量与句柄 --- */
I2C_HandleTypeDef hi2c1;
TIM_HandleTypeDef htim2;
TIM_HandleTypeDef htim3;
TIM_HandleTypeDef htim4;
UART_HandleTypeDef huart1;

/* --- 函数声明 --- */
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_TIM2_Init(void);
static void MX_TIM3_Init(void);
static void MX_I2C1_Init(void);
static void MX_USART1_UART_Init(void);
static void MX_TIM4_Init(void);

void Set_Left_Motor(int speed);
void Set_Right_Motor(int speed);
void Set_Servo_Angle(float angle);
float Get_Distance(void);
void Draw_Big_Face(uint8_t state);

/* --- 图片数据：睁眼 --- */
const unsigned char Eye_Open[] = {
0x00,0x00,0xE0,0xF8,0xFC,0xFE,0xFE,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFE,0xFE,0xFC,0xF8,0xE0,0x00,0x00,0x00,
0x00,0x3F,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xE7,0xC3,0xC3,
0xC3,0xC3,0xE7,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFC,0x00,0x00,
0x00,0x00,0x0F,0x1F,0x3F,0x7F,0x7F,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x7F,0x7F,0x3F,0x1F,0x0F,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x01,0x03,0x03,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,
0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x03,0x03,0x01,0x00,0x00,0x00,0x00,
};

/* --- 图片数据：闭眼 --- */
const unsigned char Eye_Close[] = {
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xC0,0xC0,0xE0,0xE0,0xE0,0xF0,0xF0,
0xF0,0xE0,0xE0,0xE0,0xC0,0xC0,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x03,0x03,0x07,0x07,0x07,0x0F,0x0F,0x0F,
0x0F,0x0F,0x07,0x07,0x07,0x03,0x03,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
};

/* --- 主程序 --- */
int main(void)
{
  HAL_Init();
  SystemClock_Config();

  MX_GPIO_Init();
  MX_TIM2_Init();
  MX_TIM3_Init();
  MX_I2C1_Init();
  MX_USART1_UART_Init();
  MX_TIM4_Init();

  /* 启动PWM */
  HAL_TIM_PWM_Start(&htim2, TIM_CHANNEL_1);
  HAL_TIM_PWM_Start(&htim2, TIM_CHANNEL_2);
  HAL_TIM_PWM_Start(&htim2, TIM_CHANNEL_3);
  HAL_TIM_PWM_Start(&htim2, TIM_CHANNEL_4);
  HAL_TIM_PWM_Start(&htim3, TIM_CHANNEL_3);
  HAL_TIM_Base_Start(&htim4);

  OLED_Init();
  OLED_Clear();
  Set_Servo_Angle(90.0);

  // 变量定义
  uint32_t last_blink_time = 0;
  uint8_t blink_stage = 0; // 0:睁眼, 1:闭眼
  char disp_buff[20];

  /* ---------------------- 唯一的 while(1) ---------------------- */
  while (1)
  {
    // ================= 1. 获取距离 =================
    float dist = Get_Distance();
    if(dist <= 0 || dist > 400) dist = 999; // 过滤无效值

    // ================= 2. 计算速度 (比例控制) =================
    // 目标保持 15cm
    float target_dist = 15.0f;
    float error = dist - target_dist;
    
    // 计算 PWM: 距离越远速度越快
    // Kp = 50 (系数，可调)
    int speed_pwm = (int)(error * 50.0f);

    // 限幅 (最大速度 800)
    if(speed_pwm > 800) speed_pwm = 800;
    if(speed_pwm < -800) speed_pwm = -800;

    // 死区处理 (误差在 3cm 内不动，防止抖动)
    if(abs(error) < 3.0f) speed_pwm = 0;
    
    // 起步补偿 (如果不为0但太小，给一个基础力)
    if(speed_pwm > 0 && speed_pwm < 250) speed_pwm = 250;
    if(speed_pwm < 0 && speed_pwm > -250) speed_pwm = -250;

    // ================= 3. 驱动电机 =================
    Set_Left_Motor(speed_pwm);
    Set_Right_Motor(speed_pwm);


    // ================= 4. OLED 综合显示 =================
    
    // 4.1 显示距离文字 (底部)
    if(dist < 100) sprintf(disp_buff, "Dist: %4.1f cm ", dist);
    else sprintf(disp_buff, "Dist: > 100 cm ");
    OLED_ShowString(0, 6, (uint8_t*)disp_buff, 16);

    // 4.2 表情逻辑 (大眼睛)
    // 优先级：后退(害怕) > 前进(开心) > 静止(眨眼)
    
    if (speed_pwm < -250) {
        // 后退中 -> 惊讶/向左看
        Draw_Big_Face(2);
        // 避障时，重置眨眼时间，防止冲突
        last_blink_time = HAL_GetTick(); 
    } 
    else if (speed_pwm > 250) {
        // 前进中 -> 睁大眼 (开心)
        Draw_Big_Face(0);
        last_blink_time = HAL_GetTick();
    }
    else {
        // 静止 -> 自动眨眼动画
        uint32_t now = HAL_GetTick();
        if (now - last_blink_time > 3000) {
            // 每3秒眨一次
            Draw_Big_Face(1); // 闭眼
            if (now - last_blink_time > 3200) {
                last_blink_time = now; // 200ms后重置周期
            }
        } else {
            Draw_Big_Face(0); // 睁眼
        }
    }

    HAL_Delay(50); // 循环延时
  }
}

/* --- 下面是所有功能函数 --- */

// 绘图函数: 0=睁眼, 1=闭眼, 2=惊讶(偏移)
void Draw_Big_Face(uint8_t state) {
    // 使用静态变量记录上一次状态，防止重复刷新导致闪烁
    static uint8_t last_state = 255; 
    if(state == last_state) return; 
    last_state = state;

    OLED_Clear(); // 切换表情时清屏一次
    
    if (state == 0) { // 睁眼
        OLED_DrawBMP(24, 2, 56, 6, (unsigned char*)Eye_Open);
        OLED_DrawBMP(72, 2, 104, 6, (unsigned char*)Eye_Open);
    }
    else if (state == 1) { // 闭眼
        OLED_DrawBMP(24, 2, 56, 6, (unsigned char*)Eye_Close);
        OLED_DrawBMP(72, 2, 104, 6, (unsigned char*)Eye_Close);
    }
    else if (state == 2) { // 惊讶 (眼睛左移)
        OLED_DrawBMP(10, 2, 42, 6, (unsigned char*)Eye_Open);
        OLED_DrawBMP(58, 2, 90, 6, (unsigned char*)Eye_Open);
    }
}

void delay_us(uint16_t us) {
    __HAL_TIM_SET_COUNTER(&htim4, 0);
    while (__HAL_TIM_GET_COUNTER(&htim4) < us);
}

float Get_Distance(void) {
    uint32_t ticks;
    HAL_GPIO_WritePin(GPIOA, GPIO_PIN_7, GPIO_PIN_SET);
    delay_us(10);
    HAL_GPIO_WritePin(GPIOA, GPIO_PIN_7, GPIO_PIN_RESET);
    uint32_t timeout = 0;
    while (HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_1) == GPIO_PIN_RESET) {
        if(timeout++ > 20000) return -1.0f;
    }
    __HAL_TIM_SET_COUNTER(&htim4, 0);
    while (HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_1) == GPIO_PIN_SET) {
        if(__HAL_TIM_GET_COUNTER(&htim4) > 60000) return -1.0f;
    }
    ticks = __HAL_TIM_GET_COUNTER(&htim4);
    return (float)ticks * 0.017f;
}

void Set_Left_Motor(int speed) {
    if (speed >= 0) {
        __HAL_TIM_SET_COMPARE(&htim2, TIM_CHANNEL_1, speed);
        __HAL_TIM_SET_COMPARE(&htim2, TIM_CHANNEL_2, 0);
    } else {
        __HAL_TIM_SET_COMPARE(&htim2, TIM_CHANNEL_1, 0);
        __HAL_TIM_SET_COMPARE(&htim2, TIM_CHANNEL_2, -speed);
    }
}

void Set_Right_Motor(int speed) {
    if (speed >= 0) {
        __HAL_TIM_SET_COMPARE(&htim2, TIM_CHANNEL_3, speed);
        __HAL_TIM_SET_COMPARE(&htim2, TIM_CHANNEL_4, 0);
    } else {
        __HAL_TIM_SET_COMPARE(&htim2, TIM_CHANNEL_3, 0);
        __HAL_TIM_SET_COMPARE(&htim2, TIM_CHANNEL_4, -speed);
    }
}

void Set_Servo_Angle(float angle) {
    uint32_t compare_value = 50 + (uint32_t)(angle * (200.0 / 180.0));
    __HAL_TIM_SET_COMPARE(&htim3, TIM_CHANNEL_3, compare_value);
}

/* 硬件初始化部分 (保持原样) */
void SystemClock_Config(void) {
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
  RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL9;
  HAL_RCC_OscConfig(&RCC_OscInitStruct);
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
  HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2);
}

static void MX_I2C1_Init(void) {
  hi2c1.Instance = I2C1;
  hi2c1.Init.ClockSpeed = 100000;
  hi2c1.Init.DutyCycle = I2C_DUTYCYCLE_2;
  hi2c1.Init.OwnAddress1 = 0;
  hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
  hi2c1.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
  hi2c1.Init.OwnAddress2 = 0;
  hi2c1.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
  hi2c1.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
  HAL_I2C_Init(&hi2c1);
}

static void MX_TIM2_Init(void) {
  TIM_OC_InitTypeDef sConfigOC = {0};
  htim2.Instance = TIM2;
  htim2.Init.Prescaler = 71;
  htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim2.Init.Period = 999;
  htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  HAL_TIM_PWM_Init(&htim2);
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
  sConfigOC.Pulse = 0;
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
  HAL_TIM_PWM_ConfigChannel(&htim2, &sConfigOC, TIM_CHANNEL_1);
  HAL_TIM_PWM_ConfigChannel(&htim2, &sConfigOC, TIM_CHANNEL_2);
  HAL_TIM_PWM_ConfigChannel(&htim2, &sConfigOC, TIM_CHANNEL_3);
  HAL_TIM_PWM_ConfigChannel(&htim2, &sConfigOC, TIM_CHANNEL_4);
  HAL_TIM_MspPostInit(&htim2);
}

static void MX_TIM3_Init(void) {
  TIM_OC_InitTypeDef sConfigOC = {0};
  htim3.Instance = TIM3;
  htim3.Init.Prescaler = 719;
  htim3.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim3.Init.Period = 1999;
  htim3.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  HAL_TIM_PWM_Init(&htim3);
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
  sConfigOC.Pulse = 0;
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
  HAL_TIM_PWM_ConfigChannel(&htim3, &sConfigOC, TIM_CHANNEL_3);
  HAL_TIM_MspPostInit(&htim3);
}

static void MX_TIM4_Init(void) {
  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
  htim4.Instance = TIM4;
  htim4.Init.Prescaler = 71;
  htim4.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim4.Init.Period = 65535;
  htim4.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  HAL_TIM_Base_Init(&htim4);
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
  HAL_TIM_ConfigClockSource(&htim4, &sClockSourceConfig);
}

static void MX_USART1_UART_Init(void) {
  huart1.Instance = USART1;
  huart1.Init.BaudRate = 115200;
  huart1.Init.WordLength = UART_WORDLENGTH_8B;
  huart1.Init.StopBits = UART_STOPBITS_1;
  huart1.Init.Parity = UART_PARITY_NONE;
  huart1.Init.Mode = UART_MODE_TX_RX;
  huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
  huart1.Init.OverSampling = UART_OVERSAMPLING_16;
  HAL_UART_Init(&huart1);
}

static void MX_GPIO_Init(void) {
  GPIO_InitTypeDef GPIO_InitStruct = {0};
  __HAL_RCC_GPIOD_CLK_ENABLE();
  __HAL_RCC_GPIOA_CLK_ENABLE();
  __HAL_RCC_GPIOB_CLK_ENABLE();
  HAL_GPIO_WritePin(GPIOA, GPIO_PIN_7, GPIO_PIN_RESET);
  GPIO_InitStruct.Pin = GPIO_PIN_7;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
  GPIO_InitStruct.Pin = GPIO_PIN_1;
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
}

void Error_Handler(void) {
  __disable_irq();
  while (1) {}
}
